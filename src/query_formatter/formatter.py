"""Format the query generated by the LLM"""

import re
import urllib


class QueryFormatter:
    """Format the query by handling the different errors by the LLM"""

    @classmethod
    def extract_sql(cls, query: str, return_empty: bool = False) -> str:
        """Extract the SQL code delimited by triple backticks"""
        clean_query = query.replace("googlesql", "").replace("sql", "")
        match = re.search(r"```(.*?)``", clean_query, re.DOTALL)

        if match:
            extracted = match.group(1)
            return extracted
        return "" if return_empty else query

    @classmethod
    def format_ambiguous(cls, query: str) -> str:
        """Handle amigous query error"""
        if not query:
            return ""

        ambig = re.search(r"FROM\n +`?customersegment[-\w\.]+`? AS (\w+)", query)
        if ambig:
            query = query.replace(" customer_brand_id", " " + ambig.group(1) + ".customer_brand_id")
            query = query.replace(" countr_rk", " " + ambig.group(1) + ".countr_rk")
        return query

    @classmethod
    def format_backtick(cls, query: str) -> str:
        """Handle missing backtick errors"""
        if not query:
            return ""

        missing_list = re.findall(r"`?(?:customersegment|onlinebehaviour)[-\w.]+`?", query)
        missing = set(missing_list)
        for mis in missing:
            if "`" not in mis:
                query = query.replace(mis, "`" + mis + "`")
        return query.replace("``", "`")

    @classmethod
    def format_underscore(cls, query: str) -> str:
        """Convert underscore to hyphen in project name"""
        if not query:
            return ""
        query = query.replace("customersegment_p_1d26", "customersegment-p-1d26")
        query = query.replace("onlinebehaviour_p_e4a2", "onlinebehaviour-p-e4a2")
        return query

    @classmethod
    def format_query(cls, query: str) -> str:
        """Format query generated by the LLM"""
        if "No SQL could be generated" in query:
            return ""
        query = cls.format_ambiguous(query)
        query = cls.format_backtick(query)
        query = cls.format_underscore(query)
        return query

    @classmethod
    def extract_lookml_query_params(cls, query: str) -> str:
        """Extract only the relevant LookML part from the content generated by the LLM"""
        pattern = r"`\n(.*?)\n`"
        query = query.replace("json", "")
        match = re.search(pattern, query, re.DOTALL)

        if match:
            extracted_q = match.group(1)
        else:
            # URL was not inside markdown code block
            extracted_q = query.replace(
                "Output: ", ""
            )  # remove the occasional 'Output: ' prefix added

        if extracted_q not in query:
            print("\nWARNING! Likely wrong extraction")
            print("\nOriginal answer:", query)

        return extracted_q

    @classmethod
    def extract_lookml_query_fields_param(cls, query: str) -> str:
        """Extract only the value of fields param from the URL query params"""
        extracted_fields = query  # will fallback to returning the entire query
        fields_match = re.search(r"fields=([^&]+)", query)

        if fields_match:
            extracted_fields = fields_match.group(1)

        return extracted_fields

    @classmethod
    def format_lookml_query(cls, query: str, looker_explore_base_url: str) -> str:
        """Generate the properly encoded and formatted URL query for Looker"""
        url_query_clean = query.strip().replace("\n", "")
        # Percent encoding and proper URL formatting
        query_url_fmt = urllib.parse.quote(url_query_clean, safe=":/?&=,[]{}")

        # Full URL with query params
        url = f"{looker_explore_base_url}{query_url_fmt}&toggle=dat,pik,vis&allow_login_screen=true"

        return url

    @classmethod
    def extract_python(cls, query: str) -> str:
        """Extract the python code delimited by triple backticks"""
        match = re.search(r"```python(.*?)``", query, re.DOTALL)

        if match:
            extracted = match.group(1)
            return extracted
        return ""
